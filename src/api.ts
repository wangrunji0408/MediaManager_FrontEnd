/**
 * MediaManager
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * Contact: wangrunji0408@163.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from 'querystring';
import * as url from 'url';

import * as isomorphicFetch from 'isomorphic-fetch';
import * as assign from 'core-js/library/fn/object/assign';
import {store} from './store';

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = 'http://localhost:8000'.replace(/\/+$/, '');

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = (url: string, init?: any): Promise<any> => {
          // Add auth header
          if (store.state.authOpt)
            init.headers.Authorization = store.state.authOpt.headers.Authorization;
          return fetch(url, init);
        };
    }
}

export class Body {
    'username'?: string;
    'password'?: string;
    'email'?: string;
    'phone'?: string;
}

export class Body1 {
    'path'?: string;
    'name'?: string;
    'isDir'?: boolean;
}

export class Comment {
    'id'?: number;
    'fileID'?: string;
    'userID'?: number;
    'date'?: Date;
    'type'?: CommentTypeEnum;
    'star'?: boolean;
    /**
     * 1-5
     */
    'score'?: number;
    'comment'?: string;
}

export type CommentTypeEnum = 'star' | 'score' | 'comment';
export class ErrorInfo {
    'info'?: string;
}

export class Event {
    'date'?: Date;
    /**
     * For now, just describe events in plain string ...
     */
    'content'?: string;
}

export class File {
    'id'?: string;
    'ownerID'?: number;
    'isDir'?: boolean;
    /**
     * File name
     */
    'name'?: string;
    /**
     * Absolute path, name is not included
     */
    'path'?: string;
    'md5'?: string;
    /**
     * image url
     */
    'thumbnails'?: string;
    /**
     * in bytes
     */
    'size'?: number;
    'modifyDate'?: Date;
    'createDate'?: Date;
    'tags'?: Array<FileTag>;
    /**
     * Only available when get by admin or owner
     */
    'shareToGroups'?: Array<UserGroup>;
    'videoInfo'?: VideoInfo;
}

export class FileStat {
    'previewCount'?: number;
    'downloadCount'?: number;
    'chartData'?: Array<FileStatChartData>;
}

export class FileStatChartData {
    'date'?: Date;
    'previewCount'?: number;
    'downloadCount'?: number;
}

export class FileTag {
    'id'?: number;
    'name'?: string;
    'color'?: string;
}

export class InlineResponse200 {
    'token'?: string;
    'userID'?: number;
}

export class SpaceInfo {
    'totalSize'?: number;
    'usedSize'?: number;
}

export class User {
    'id'?: number;
    'username'?: string;
    'password'?: string;
    'firstName'?: string;
    'lastName'?: string;
    'email'?: string;
    'phone'?: string;
    'groups'?: Array<UserGroup>;
    'space'?: SpaceInfo;
}

export class UserGroup {
    'id'?: number;
    'name'?: string;
    /**
     * like: #FF9900
     */
    'color'?: string;
}

export class UserStat {
    'uploadCount'?: number;
    'downloadCount'?: number;
    'chartData'?: Array<UserStatChartData>;
}

export class UserStatChartData {
    'date'?: Date;
    'uploadCount'?: number;
    'downloadCount'?: number;
    'uploadSize'?: number;
    'downloadSize'?: number;
}

export class VideoInfo {
    'duration'?: string;
    'colorChannel'?: string;
    'bitRate'?: string;
    'resolution'?: string;
    'aspectRatio'?: string;
}



/**
 * FileApi - fetch parameter creator
 */
export const FileApiFetchParamCreator = {
    /**
     * 新建空白文件或文件夹
     * @summary Create file or directory
     * @param body
     */
    createFile(params: {  'body': Body1; }, options?: any): FetchArgs {
        // verify required parameter "body" is set
        if (params['body'] == null) {
            throw new Error('Missing required parameter body when calling createFile');
        }
        const baseUrl = `/file`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['body']) {
            fetchOptions.body = JSON.stringify(params['body'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete file or directory
     * @param id File id
     */
    deleteFile(params: {  'id': string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling deleteFile');
        }
        const baseUrl = `/file/{id}`
            .replace(`{${'id'}}`, `${ params['id'] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Download file
     * @param id File id
     */
    downloadFile(params: {  'id': string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling downloadFile');
        }
        const baseUrl = `/file/{id}/data`
            .replace(`{${'id'}}`, `${ params['id'] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Used for searching files
     * @summary Get file info by Id
     * @param id File id
     */
    getFileById(params: {  'id': string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling getFileById');
        }
        const baseUrl = `/file/{id}`
            .replace(`{${'id'}}`, `${ params['id'] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Used for searching files
     * @summary Get file infos by query
     * @param path File path. Regex.
     * @param name File name. Regex.
     * @param tags File tag IDs
     */
    getFiles(params: {  'path'?: string; 'name'?: string; 'tags'?: Array<number>; }, options?: any): FetchArgs {
        const baseUrl = `/file`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            'path': params['path'],
            'name': params['name'],
            'tags': params['tags'],
        });
        let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 这个接口用于对一些文件进行一些操作。  权限：仅对管理员及文件所有者有效。  对每个文件，除 id 属性外   通过提供对应属性的新值来指示进行哪些操作：  * 重命名 name   * 移动位置 path   * 修改标签 tags   * 修改分享到组 shareToGroups    后端需逐条判断是否有值，是否变化，然后进行操作。对其它属性的修改均无效。  若全部操作成功，则返回200。否则返回400，描述每个失败操作。  由于微信小程序不支持PATCH，故改为PUT。然而实质上这是个PATCH。
     * @summary Do some commands on files.
     * @param body Updated file object
     */
    updateFiles(params: {  'body': Array<File>; }, options?: any): FetchArgs {
        // verify required parameter "body" is set
        if (params['body'] == null) {
            throw new Error('Missing required parameter body when calling updateFiles');
        }
        const baseUrl = `/file`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['body']) {
            fetchOptions.body = JSON.stringify(params['body'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * ID = 0 if uploading a new file
     * @summary Upload file or update file data.
     * @param id File id
     * @param file The file to upload.
     * @param path Base path
     */
    uploadFile(params: {  'id': string; 'file'?: any; 'path'?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling uploadFile');
        }
        const baseUrl = `/file/{id}/data`
            .replace(`{${'id'}}`, `${ params['id'] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);

        let body = new FormData();
        body.append('file', params['file']);
        body.append('path', params['path']);
        fetchOptions.body = body;
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * FileApi - functional programming interface
 */
export const FileApiFp = {
    /**
     * 新建空白文件或文件夹
     * @summary Create file or directory
     * @param body
     */
    createFile(params: { 'body': Body1;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<File> {
        const fetchArgs = FileApiFetchParamCreator.createFile(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete file or directory
     * @param id File id
     */
    deleteFile(params: { 'id': string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = FileApiFetchParamCreator.deleteFile(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Download file
     * @param id File id
     */
    downloadFile(params: { 'id': string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = FileApiFetchParamCreator.downloadFile(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Used for searching files
     * @summary Get file info by Id
     * @param id File id
     */
    getFileById(params: { 'id': string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<File> {
        const fetchArgs = FileApiFetchParamCreator.getFileById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Used for searching files
     * @summary Get file infos by query
     * @param path File path. Regex.
     * @param name File name. Regex.
     * @param tags File tag IDs
     */
    getFiles(params: { 'path'?: string; 'name'?: string; 'tags'?: Array<number>;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<File>> {
        const fetchArgs = FileApiFetchParamCreator.getFiles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 这个接口用于对一些文件进行一些操作。  权限：仅对管理员及文件所有者有效。  对每个文件，除 id 属性外   通过提供对应属性的新值来指示进行哪些操作：  * 重命名 name   * 移动位置 path   * 修改标签 tags   * 修改分享到组 shareToGroups    后端需逐条判断是否有值，是否变化，然后进行操作。对其它属性的修改均无效。  若全部操作成功，则返回200。否则返回400，描述每个失败操作。  由于微信小程序不支持PATCH，故改为PUT。然而实质上这是个PATCH。
     * @summary Do some commands on files.
     * @param body Updated file object
     */
    updateFiles(params: { 'body': Array<File>;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = FileApiFetchParamCreator.updateFiles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * ID = 0 if uploading a new file
     * @summary Upload file or update file data.
     * @param id File id
     * @param file The file to upload.
     * @param path Base path
     */
    uploadFile(params: { 'id': string; 'file'?: any; 'path'?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<File> {
        const fetchArgs = FileApiFetchParamCreator.uploadFile(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * FileApi - object-oriented interface
 */
export class FileApi extends BaseAPI {
    /**
     * 新建空白文件或文件夹
     * @summary Create file or directory
     * @param body
     */
    createFile(params: {  'body': Body1; }, options?: any) {
        return FileApiFp.createFile(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete file or directory
     * @param id File id
     */
    deleteFile(params: {  'id': string; }, options?: any) {
        return FileApiFp.deleteFile(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Download file
     * @param id File id
     */
    downloadFile(params: {  'id': string; }, options?: any) {
        return FileApiFp.downloadFile(params, options)(this.fetch, this.basePath);
    }
    /**
     * Used for searching files
     * @summary Get file info by Id
     * @param id File id
     */
    getFileById(params: {  'id': string; }, options?: any) {
        return FileApiFp.getFileById(params, options)(this.fetch, this.basePath);
    }
    /**
     * Used for searching files
     * @summary Get file infos by query
     * @param path File path. Regex.
     * @param name File name. Regex.
     * @param tags File tag IDs
     */
    getFiles(params: {  'path'?: string; 'name'?: string; 'tags'?: Array<number>; }, options?: any) {
        return FileApiFp.getFiles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 这个接口用于对一些文件进行一些操作。  权限：仅对管理员及文件所有者有效。  对每个文件，除 id 属性外   通过提供对应属性的新值来指示进行哪些操作：  * 重命名 name   * 移动位置 path   * 修改标签 tags   * 修改分享到组 shareToGroups    后端需逐条判断是否有值，是否变化，然后进行操作。对其它属性的修改均无效。  若全部操作成功，则返回200。否则返回400，描述每个失败操作。  由于微信小程序不支持PATCH，故改为PUT。然而实质上这是个PATCH。
     * @summary Do some commands on files.
     * @param body Updated file object
     */
    updateFiles(params: {  'body': Array<File>; }, options?: any) {
        return FileApiFp.updateFiles(params, options)(this.fetch, this.basePath);
    }
    /**
     * ID = 0 if uploading a new file
     * @summary Upload file or update file data.
     * @param id File id
     * @param file The file to upload.
     * @param path Base path
     */
    uploadFile(params: {  'id': string; 'file'?: any; 'path'?: string; }, options?: any) {
        return FileApiFp.uploadFile(params, options)(this.fetch, this.basePath);
    }
}

/**
 * FileApi - factory interface
 */
export const FileApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 新建空白文件或文件夹
         * @summary Create file or directory
         * @param body
         */
        createFile(params: {  'body': Body1; }, options?: any) {
            return FileApiFp.createFile(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete file or directory
         * @param id File id
         */
        deleteFile(params: {  'id': string; }, options?: any) {
            return FileApiFp.deleteFile(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Download file
         * @param id File id
         */
        downloadFile(params: {  'id': string; }, options?: any) {
            return FileApiFp.downloadFile(params, options)(fetch, basePath);
        },
        /**
         * Used for searching files
         * @summary Get file info by Id
         * @param id File id
         */
        getFileById(params: {  'id': string; }, options?: any) {
            return FileApiFp.getFileById(params, options)(fetch, basePath);
        },
        /**
         * Used for searching files
         * @summary Get file infos by query
         * @param path File path. Regex.
         * @param name File name. Regex.
         * @param tags File tag IDs
         */
        getFiles(params: {  'path'?: string; 'name'?: string; 'tags'?: Array<number>; }, options?: any) {
            return FileApiFp.getFiles(params, options)(fetch, basePath);
        },
        /**
         * 这个接口用于对一些文件进行一些操作。  权限：仅对管理员及文件所有者有效。  对每个文件，除 id 属性外   通过提供对应属性的新值来指示进行哪些操作：  * 重命名 name   * 移动位置 path   * 修改标签 tags   * 修改分享到组 shareToGroups    后端需逐条判断是否有值，是否变化，然后进行操作。对其它属性的修改均无效。  若全部操作成功，则返回200。否则返回400，描述每个失败操作。  由于微信小程序不支持PATCH，故改为PUT。然而实质上这是个PATCH。
         * @summary Do some commands on files.
         * @param body Updated file object
         */
        updateFiles(params: {  'body': Array<File>; }, options?: any) {
            return FileApiFp.updateFiles(params, options)(fetch, basePath);
        },
        /**
         * ID = 0 if uploading a new file
         * @summary Upload file or update file data.
         * @param id File id
         * @param file The file to upload.
         * @param path Base path
         */
        uploadFile(params: {  'id': string; 'file'?: any; 'path'?: string; }, options?: any) {
            return FileApiFp.uploadFile(params, options)(fetch, basePath);
        },
    };
};


/**
 * FiletagApi - fetch parameter creator
 */
export const FiletagApiFetchParamCreator = {
    /**
     *
     * @summary Create file tag
     * @param body Created file tag
     */
    createFileTag(params: {  'body': FileTag; }, options?: any): FetchArgs {
        // verify required parameter "body" is set
        if (params['body'] == null) {
            throw new Error('Missing required parameter body when calling createFileTag');
        }
        const baseUrl = `/filetag`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['body']) {
            fetchOptions.body = JSON.stringify(params['body'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * And remove it in all files
     * @summary Delete file tag
     * @param id
     */
    deleteFileTag(params: {  'id': number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling deleteFileTag');
        }
        const baseUrl = `/filetag/{id}`
            .replace(`{${'id'}}`, `${ params['id'] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Get file tag by ID
     * @param id
     */
    getFileTagById(params: {  'id': number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling getFileTagById');
        }
        const baseUrl = `/filetag/{id}`
            .replace(`{${'id'}}`, `${ params['id'] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Get all file tags
     */
    getFileTags(options?: any): FetchArgs {
        const baseUrl = `/filetag`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update file tag
     * @param id
     * @param body Updated file tag object
     */
    updateFileTag(params: {  'id': number; 'body': FileTag; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling updateFileTag');
        }
        // verify required parameter "body" is set
        if (params['body'] == null) {
            throw new Error('Missing required parameter body when calling updateFileTag');
        }
        const baseUrl = `/filetag/{id}`
            .replace(`{${'id'}}`, `${ params['id'] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['body']) {
            fetchOptions.body = JSON.stringify(params['body'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * FiletagApi - functional programming interface
 */
export const FiletagApiFp = {
    /**
     *
     * @summary Create file tag
     * @param body Created file tag
     */
    createFileTag(params: { 'body': FileTag;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FileTag> {
        const fetchArgs = FiletagApiFetchParamCreator.createFileTag(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * And remove it in all files
     * @summary Delete file tag
     * @param id
     */
    deleteFileTag(params: { 'id': number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = FiletagApiFetchParamCreator.deleteFileTag(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Get file tag by ID
     * @param id
     */
    getFileTagById(params: { 'id': number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FileTag> {
        const fetchArgs = FiletagApiFetchParamCreator.getFileTagById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Get all file tags
     */
    getFileTags(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FileTag>> {
        const fetchArgs = FiletagApiFetchParamCreator.getFileTags(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update file tag
     * @param id
     * @param body Updated file tag object
     */
    updateFileTag(params: { 'id': number; 'body': FileTag;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FileTag> {
        const fetchArgs = FiletagApiFetchParamCreator.updateFileTag(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * FiletagApi - object-oriented interface
 */
export class FiletagApi extends BaseAPI {
    /**
     *
     * @summary Create file tag
     * @param body Created file tag
     */
    createFileTag(params: {  'body': FileTag; }, options?: any) {
        return FiletagApiFp.createFileTag(params, options)(this.fetch, this.basePath);
    }
    /**
     * And remove it in all files
     * @summary Delete file tag
     * @param id
     */
    deleteFileTag(params: {  'id': number; }, options?: any) {
        return FiletagApiFp.deleteFileTag(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Get file tag by ID
     * @param id
     */
    getFileTagById(params: {  'id': number; }, options?: any) {
        return FiletagApiFp.getFileTagById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Get all file tags
     */
    getFileTags(options?: any) {
        return FiletagApiFp.getFileTags(options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update file tag
     * @param id
     * @param body Updated file tag object
     */
    updateFileTag(params: {  'id': number; 'body': FileTag; }, options?: any) {
        return FiletagApiFp.updateFileTag(params, options)(this.fetch, this.basePath);
    }
}

/**
 * FiletagApi - factory interface
 */
export const FiletagApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Create file tag
         * @param body Created file tag
         */
        createFileTag(params: {  'body': FileTag; }, options?: any) {
            return FiletagApiFp.createFileTag(params, options)(fetch, basePath);
        },
        /**
         * And remove it in all files
         * @summary Delete file tag
         * @param id
         */
        deleteFileTag(params: {  'id': number; }, options?: any) {
            return FiletagApiFp.deleteFileTag(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get file tag by ID
         * @param id
         */
        getFileTagById(params: {  'id': number; }, options?: any) {
            return FiletagApiFp.getFileTagById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all file tags
         */
        getFileTags(options?: any) {
            return FiletagApiFp.getFileTags(options)(fetch, basePath);
        },
        /**
         *
         * @summary Update file tag
         * @param id
         * @param body Updated file tag object
         */
        updateFileTag(params: {  'id': number; 'body': FileTag; }, options?: any) {
            return FiletagApiFp.updateFileTag(params, options)(fetch, basePath);
        },
    };
};


/**
 * GroupApi - fetch parameter creator
 */
export const GroupApiFetchParamCreator = {
    /**
     * 管理员用户创建新用户组
     * @summary Create group
     * @param body Created user group
     */
    createUserGroup(params: {  'body': UserGroup; }, options?: any): FetchArgs {
        // verify required parameter "body" is set
        if (params['body'] == null) {
            throw new Error('Missing required parameter body when calling createUserGroup');
        }
        const baseUrl = `/group`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['body']) {
            fetchOptions.body = JSON.stringify(params['body'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 删除用户组，同时删除组内用户的标记
     * @summary Delete user group
     * @param id
     */
    deleteUserGroup(params: {  'id': number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling deleteUserGroup');
        }
        const baseUrl = `/group/{id}`
            .replace(`{${'id'}}`, `${ params['id'] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Get group by id
     * @param id
     */
    getUserGroupById(params: {  'id': number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling getUserGroupById');
        }
        const baseUrl = `/group/{id}`
            .replace(`{${'id'}}`, `${ params['id'] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Get all user groups
     */
    getUserGroups(options?: any): FetchArgs {
        const baseUrl = `/group`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update group
     * @param id
     * @param body Updated group object
     */
    updateUserGroup(params: {  'id': number; 'body': UserGroup; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling updateUserGroup');
        }
        // verify required parameter "body" is set
        if (params['body'] == null) {
            throw new Error('Missing required parameter body when calling updateUserGroup');
        }
        const baseUrl = `/group/{id}`
            .replace(`{${'id'}}`, `${ params['id'] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['body']) {
            fetchOptions.body = JSON.stringify(params['body'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * GroupApi - functional programming interface
 */
export const GroupApiFp = {
    /**
     * 管理员用户创建新用户组
     * @summary Create group
     * @param body Created user group
     */
    createUserGroup(params: { 'body': UserGroup;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserGroup> {
        const fetchArgs = GroupApiFetchParamCreator.createUserGroup(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 删除用户组，同时删除组内用户的标记
     * @summary Delete user group
     * @param id
     */
    deleteUserGroup(params: { 'id': number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GroupApiFetchParamCreator.deleteUserGroup(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Get group by id
     * @param id
     */
    getUserGroupById(params: { 'id': number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserGroup> {
        const fetchArgs = GroupApiFetchParamCreator.getUserGroupById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Get all user groups
     */
    getUserGroups(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserGroup>> {
        const fetchArgs = GroupApiFetchParamCreator.getUserGroups(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update group
     * @param id
     * @param body Updated group object
     */
    updateUserGroup(params: { 'id': number; 'body': UserGroup;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserGroup> {
        const fetchArgs = GroupApiFetchParamCreator.updateUserGroup(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * GroupApi - object-oriented interface
 */
export class GroupApi extends BaseAPI {
    /**
     * 管理员用户创建新用户组
     * @summary Create group
     * @param body Created user group
     */
    createUserGroup(params: {  'body': UserGroup; }, options?: any) {
        return GroupApiFp.createUserGroup(params, options)(this.fetch, this.basePath);
    }
    /**
     * 删除用户组，同时删除组内用户的标记
     * @summary Delete user group
     * @param id
     */
    deleteUserGroup(params: {  'id': number; }, options?: any) {
        return GroupApiFp.deleteUserGroup(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Get group by id
     * @param id
     */
    getUserGroupById(params: {  'id': number; }, options?: any) {
        return GroupApiFp.getUserGroupById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Get all user groups
     */
    getUserGroups(options?: any) {
        return GroupApiFp.getUserGroups(options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update group
     * @param id
     * @param body Updated group object
     */
    updateUserGroup(params: {  'id': number; 'body': UserGroup; }, options?: any) {
        return GroupApiFp.updateUserGroup(params, options)(this.fetch, this.basePath);
    }
}

/**
 * GroupApi - factory interface
 */
export const GroupApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 管理员用户创建新用户组
         * @summary Create group
         * @param body Created user group
         */
        createUserGroup(params: {  'body': UserGroup; }, options?: any) {
            return GroupApiFp.createUserGroup(params, options)(fetch, basePath);
        },
        /**
         * 删除用户组，同时删除组内用户的标记
         * @summary Delete user group
         * @param id
         */
        deleteUserGroup(params: {  'id': number; }, options?: any) {
            return GroupApiFp.deleteUserGroup(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get group by id
         * @param id
         */
        getUserGroupById(params: {  'id': number; }, options?: any) {
            return GroupApiFp.getUserGroupById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all user groups
         */
        getUserGroups(options?: any) {
            return GroupApiFp.getUserGroups(options)(fetch, basePath);
        },
        /**
         *
         * @summary Update group
         * @param id
         * @param body Updated group object
         */
        updateUserGroup(params: {  'id': number; 'body': UserGroup; }, options?: any) {
            return GroupApiFp.updateUserGroup(params, options)(fetch, basePath);
        },
    };
};


/**
 * OtherApi - fetch parameter creator
 */
export const OtherApiFetchParamCreator = {
    /**
     *
     * @summary Search similar image by given image
     * @param imageFile
     */
    searchSimilarImage(params: {  'imageFile'?: any; }, options?: any): FetchArgs {
        const baseUrl = `/image/similar`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            'imageFile': params['imageFile'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * OtherApi - functional programming interface
 */
export const OtherApiFp = {
    /**
     *
     * @summary Search similar image by given image
     * @param imageFile
     */
    searchSimilarImage(params: { 'imageFile'?: any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<File>> {
        const fetchArgs = OtherApiFetchParamCreator.searchSimilarImage(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * OtherApi - object-oriented interface
 */
export class OtherApi extends BaseAPI {
    /**
     *
     * @summary Search similar image by given image
     * @param imageFile
     */
    searchSimilarImage(params: {  'imageFile'?: any; }, options?: any) {
        return OtherApiFp.searchSimilarImage(params, options)(this.fetch, this.basePath);
    }
}

/**
 * OtherApi - factory interface
 */
export const OtherApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Search similar image by given image
         * @param imageFile
         */
        searchSimilarImage(params: {  'imageFile'?: any; }, options?: any) {
            return OtherApiFp.searchSimilarImage(params, options)(fetch, basePath);
        },
    };
};


/**
 * SocialApi - fetch parameter creator
 */
export const SocialApiFetchParamCreator = {
    /**
     *
     * @summary Delete the comment
     * @param id Comment id
     */
    deleteComment(params: {  'id': number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling deleteComment');
        }
        const baseUrl = `/comment/{id}`
            .replace(`{${'id'}}`, `${ params['id'] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Follow another user
     * @param id
     * @param othersID
     */
    followUser(params: {  'id': number; 'othersID': number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling followUser');
        }
        // verify required parameter "othersID" is set
        if (params['othersID'] == null) {
            throw new Error('Missing required parameter othersID when calling followUser');
        }
        const baseUrl = `/user/{id}/following/{othersID}`
            .replace(`{${'id'}}`, `${ params['id'] }`)
            .replace(`{${'othersID'}}`, `${ params['othersID'] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Get all comments about the file
     * @param fileID File id
     * @param type Comment type
     */
    getFileComments(params: {  'fileID': string; 'type'?: string; }, options?: any): FetchArgs {
        // verify required parameter "fileID" is set
        if (params['fileID'] == null) {
            throw new Error('Missing required parameter fileID when calling getFileComments');
        }
        const baseUrl = `/comment`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            'fileID': params['fileID'],
            'type': params['type'],
        });
        let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Get all events of the user after a given time
     * @param userID
     * @param afterTime Use last login time for default.
     */
    getUserEvents(params: {  'userID': number; 'afterTime'?: Date; }, options?: any): FetchArgs {
        // verify required parameter "userID" is set
        if (params['userID'] == null) {
            throw new Error('Missing required parameter userID when calling getUserEvents');
        }
        const baseUrl = `/event`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            'userID': params['userID'],
            'afterTime': params['afterTime'],
        });
        let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Get all followers of the user
     * @param id
     */
    getUserFollower(params: {  'id': number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling getUserFollower');
        }
        const baseUrl = `/user/{id}/follower`
            .replace(`{${'id'}}`, `${ params['id'] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Get all followings of the user
     * @param id
     */
    getUserFollowing(params: {  'id': number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling getUserFollowing');
        }
        const baseUrl = `/user/{id}/following`
            .replace(`{${'id'}}`, `${ params['id'] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Post new comment about the file
     * @param body
     */
    postComment(params: {  'body': Comment; }, options?: any): FetchArgs {
        // verify required parameter "body" is set
        if (params['body'] == null) {
            throw new Error('Missing required parameter body when calling postComment');
        }
        const baseUrl = `/comment`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['body']) {
            fetchOptions.body = JSON.stringify(params['body'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Unfollow another user
     * @param id
     * @param othersID
     */
    unfollowUser(params: {  'id': number; 'othersID': number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling unfollowUser');
        }
        // verify required parameter "othersID" is set
        if (params['othersID'] == null) {
            throw new Error('Missing required parameter othersID when calling unfollowUser');
        }
        const baseUrl = `/user/{id}/following/{othersID}`
            .replace(`{${'id'}}`, `${ params['id'] }`)
            .replace(`{${'othersID'}}`, `${ params['othersID'] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update comment
     * @param body
     */
    updateComment(params: {  'body': Comment; }, options?: any): FetchArgs {
        // verify required parameter "body" is set
        if (params['body'] == null) {
            throw new Error('Missing required parameter body when calling updateComment');
        }
        const baseUrl = `/comment`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['body']) {
            fetchOptions.body = JSON.stringify(params['body'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * SocialApi - functional programming interface
 */
export const SocialApiFp = {
    /**
     *
     * @summary Delete the comment
     * @param id Comment id
     */
    deleteComment(params: { 'id': number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SocialApiFetchParamCreator.deleteComment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Follow another user
     * @param id
     * @param othersID
     */
    followUser(params: { 'id': number; 'othersID': number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SocialApiFetchParamCreator.followUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Get all comments about the file
     * @param fileID File id
     * @param type Comment type
     */
    getFileComments(params: { 'fileID': string; 'type'?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Comment>> {
        const fetchArgs = SocialApiFetchParamCreator.getFileComments(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Get all events of the user after a given time
     * @param userID
     * @param afterTime Use last login time for default.
     */
    getUserEvents(params: { 'userID': number; 'afterTime'?: Date;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Event>> {
        const fetchArgs = SocialApiFetchParamCreator.getUserEvents(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Get all followers of the user
     * @param id
     */
    getUserFollower(params: { 'id': number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
        const fetchArgs = SocialApiFetchParamCreator.getUserFollower(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Get all followings of the user
     * @param id
     */
    getUserFollowing(params: { 'id': number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<number>> {
        const fetchArgs = SocialApiFetchParamCreator.getUserFollowing(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Post new comment about the file
     * @param body
     */
    postComment(params: { 'body': Comment;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Comment> {
        const fetchArgs = SocialApiFetchParamCreator.postComment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Unfollow another user
     * @param id
     * @param othersID
     */
    unfollowUser(params: { 'id': number; 'othersID': number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SocialApiFetchParamCreator.unfollowUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update comment
     * @param body
     */
    updateComment(params: { 'body': Comment;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Comment> {
        const fetchArgs = SocialApiFetchParamCreator.updateComment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * SocialApi - object-oriented interface
 */
export class SocialApi extends BaseAPI {
    /**
     *
     * @summary Delete the comment
     * @param id Comment id
     */
    deleteComment(params: {  'id': number; }, options?: any) {
        return SocialApiFp.deleteComment(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Follow another user
     * @param id
     * @param othersID
     */
    followUser(params: {  'id': number; 'othersID': number; }, options?: any) {
        return SocialApiFp.followUser(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Get all comments about the file
     * @param fileID File id
     * @param type Comment type
     */
    getFileComments(params: {  'fileID': string; 'type'?: string; }, options?: any) {
        return SocialApiFp.getFileComments(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Get all events of the user after a given time
     * @param userID
     * @param afterTime Use last login time for default.
     */
    getUserEvents(params: {  'userID': number; 'afterTime'?: Date; }, options?: any) {
        return SocialApiFp.getUserEvents(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Get all followers of the user
     * @param id
     */
    getUserFollower(params: {  'id': number; }, options?: any) {
        return SocialApiFp.getUserFollower(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Get all followings of the user
     * @param id
     */
    getUserFollowing(params: {  'id': number; }, options?: any) {
        return SocialApiFp.getUserFollowing(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Post new comment about the file
     * @param body
     */
    postComment(params: {  'body': Comment; }, options?: any) {
        return SocialApiFp.postComment(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Unfollow another user
     * @param id
     * @param othersID
     */
    unfollowUser(params: {  'id': number; 'othersID': number; }, options?: any) {
        return SocialApiFp.unfollowUser(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update comment
     * @param body
     */
    updateComment(params: {  'body': Comment; }, options?: any) {
        return SocialApiFp.updateComment(params, options)(this.fetch, this.basePath);
    }
}

/**
 * SocialApi - factory interface
 */
export const SocialApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Delete the comment
         * @param id Comment id
         */
        deleteComment(params: {  'id': number; }, options?: any) {
            return SocialApiFp.deleteComment(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Follow another user
         * @param id
         * @param othersID
         */
        followUser(params: {  'id': number; 'othersID': number; }, options?: any) {
            return SocialApiFp.followUser(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all comments about the file
         * @param fileID File id
         * @param type Comment type
         */
        getFileComments(params: {  'fileID': string; 'type'?: string; }, options?: any) {
            return SocialApiFp.getFileComments(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all events of the user after a given time
         * @param userID
         * @param afterTime Use last login time for default.
         */
        getUserEvents(params: {  'userID': number; 'afterTime'?: Date; }, options?: any) {
            return SocialApiFp.getUserEvents(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all followers of the user
         * @param id
         */
        getUserFollower(params: {  'id': number; }, options?: any) {
            return SocialApiFp.getUserFollower(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get all followings of the user
         * @param id
         */
        getUserFollowing(params: {  'id': number; }, options?: any) {
            return SocialApiFp.getUserFollowing(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Post new comment about the file
         * @param body
         */
        postComment(params: {  'body': Comment; }, options?: any) {
            return SocialApiFp.postComment(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Unfollow another user
         * @param id
         * @param othersID
         */
        unfollowUser(params: {  'id': number; 'othersID': number; }, options?: any) {
            return SocialApiFp.unfollowUser(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update comment
         * @param body
         */
        updateComment(params: {  'body': Comment; }, options?: any) {
            return SocialApiFp.updateComment(params, options)(fetch, basePath);
        },
    };
};


/**
 * StatisticApi - fetch parameter creator
 */
export const StatisticApiFetchParamCreator = {
    /**
     *
     * @summary Get file statistic info
     * @param id
     */
    getFileStatistic(params: {  'id': string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling getFileStatistic');
        }
        const baseUrl = `/statistic/file/{id}`
            .replace(`{${'id'}}`, `${ params['id'] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Get user statistic info
     * @param id
     */
    getUserStatistic(params: {  'id': number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling getUserStatistic');
        }
        const baseUrl = `/statistic/user/{id}`
            .replace(`{${'id'}}`, `${ params['id'] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * StatisticApi - functional programming interface
 */
export const StatisticApiFp = {
    /**
     *
     * @summary Get file statistic info
     * @param id
     */
    getFileStatistic(params: { 'id': string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FileStat> {
        const fetchArgs = StatisticApiFetchParamCreator.getFileStatistic(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Get user statistic info
     * @param id
     */
    getUserStatistic(params: { 'id': number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserStat> {
        const fetchArgs = StatisticApiFetchParamCreator.getUserStatistic(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * StatisticApi - object-oriented interface
 */
export class StatisticApi extends BaseAPI {
    /**
     *
     * @summary Get file statistic info
     * @param id
     */
    getFileStatistic(params: {  'id': string; }, options?: any) {
        return StatisticApiFp.getFileStatistic(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Get user statistic info
     * @param id
     */
    getUserStatistic(params: {  'id': number; }, options?: any) {
        return StatisticApiFp.getUserStatistic(params, options)(this.fetch, this.basePath);
    }
}

/**
 * StatisticApi - factory interface
 */
export const StatisticApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Get file statistic info
         * @param id
         */
        getFileStatistic(params: {  'id': string; }, options?: any) {
            return StatisticApiFp.getFileStatistic(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get user statistic info
         * @param id
         */
        getUserStatistic(params: {  'id': number; }, options?: any) {
            return StatisticApiFp.getUserStatistic(params, options)(fetch, basePath);
        },
    };
};


/**
 * UserApi - fetch parameter creator
 */
export const UserApiFetchParamCreator = {
    /**
     *
     * @summary Change user password
     * @param id
     * @param oldPassword
     * @param newPassword
     */
    changeUserPassword(params: {  'id': number; 'oldPassword': string; 'newPassword': string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling changeUserPassword');
        }
        // verify required parameter "oldPassword" is set
        if (params['oldPassword'] == null) {
            throw new Error('Missing required parameter oldPassword when calling changeUserPassword');
        }
        // verify required parameter "newPassword" is set
        if (params['newPassword'] == null) {
            throw new Error('Missing required parameter newPassword when calling changeUserPassword');
        }
        const baseUrl = `/user/{id}/password`
            .replace(`{${'id'}}`, `${ params['id'] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            'oldPassword': params['oldPassword'],
            'newPassword': params['newPassword'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 管理员用户创建新用户
     * @summary Create user
     * @param body Created user object (Ignore id)
     */
    createUser(params: {  'body': User; }, options?: any): FetchArgs {
        // verify required parameter "body" is set
        if (params['body'] == null) {
            throw new Error('Missing required parameter body when calling createUser');
        }
        const baseUrl = `/user`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['body']) {
            fetchOptions.body = JSON.stringify(params['body'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This can only be done by the admin user.
     * @summary Delete user
     * @param id
     */
    deleteUser(params: {  'id': number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling deleteUser');
        }
        const baseUrl = `/user/{id}`
            .replace(`{${'id'}}`, `${ params['id'] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'DELETE' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 搜索用户
     * @summary Get user by query
     * @param name User name regex
     * @param group User group id
     */
    getUser(params: {  'name'?: string; 'group'?: number; }, options?: any): FetchArgs {
        const baseUrl = `/user`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            'name': params['name'],
            'group': params['group'],
        });
        let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Get user avatar image
     * @param id
     */
    getUserAvatar(params: {  'id': number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling getUserAvatar');
        }
        const baseUrl = `/user/{id}/avatar`
            .replace(`{${'id'}}`, `${ params['id'] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Get user by ID
     * @param id
     */
    getUserByName(params: {  'id': number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling getUserByName');
        }
        const baseUrl = `/user/{id}`
            .replace(`{${'id'}}`, `${ params['id'] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Logs user into the system. Return a token.
     * @param username The user name for login
     * @param password The password for login in clear text
     */
    loginUser(params: {  'username': string; 'password': string; }, options?: any): FetchArgs {
        // verify required parameter "username" is set
        if (params['username'] == null) {
            throw new Error('Missing required parameter username when calling loginUser');
        }
        // verify required parameter "password" is set
        if (params['password'] == null) {
            throw new Error('Missing required parameter password when calling loginUser');
        }
        const baseUrl = `/user/login`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            'username': params['username'],
            'password': params['password'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Logs out current logged in user session
     */
    logoutUser(options?: any): FetchArgs {
        const baseUrl = `/user/logout`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'GET' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 游客自助注册用户
     * @summary Signup user. Return a token.
     * @param body
     */
    signupUser(params: {  'body': Body; }, options?: any): FetchArgs {
        // verify required parameter "body" is set
        if (params['body'] == null) {
            throw new Error('Missing required parameter body when calling signupUser');
        }
        const baseUrl = `/user/signup`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['body']) {
            fetchOptions.body = JSON.stringify(params['body'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This can only be done by the logged in user.
     * @summary Update user
     * @param id
     * @param body Updated user object
     */
    updateUser(params: {  'id': number; 'body': User; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling updateUser');
        }
        // verify required parameter "body" is set
        if (params['body'] == null) {
            throw new Error('Missing required parameter body when calling updateUser');
        }
        const baseUrl = `/user/{id}`
            .replace(`{${'id'}}`, `${ params['id'] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'PUT' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { 'Content-Type': 'application/json' };
        if (params['body']) {
            fetchOptions.body = JSON.stringify(params['body'] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Upload user avatar image
     * @param id
     * @param file The image to upload.
     */
    uploadUserAvatar(params: {  'id': number; 'file'?: any; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params['id'] == null) {
            throw new Error('Missing required parameter id when calling uploadUserAvatar');
        }
        const baseUrl = `/user/{id}/avatar`
            .replace(`{${'id'}}`, `${ params['id'] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: 'POST' }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { 'Content-Type': 'application/x-www-form-urlencoded' };
        fetchOptions.body = querystring.stringify({
            'file': params['file'],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = {
    /**
     *
     * @summary Change user password
     * @param id
     * @param oldPassword
     * @param newPassword
     */
    changeUserPassword(params: { 'id': number; 'oldPassword': string; 'newPassword': string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.changeUserPassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 管理员用户创建新用户
     * @summary Create user
     * @param body Created user object (Ignore id)
     */
    createUser(params: { 'body': User;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.createUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This can only be done by the admin user.
     * @summary Delete user
     * @param id
     */
    deleteUser(params: { 'id': number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.deleteUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 搜索用户
     * @summary Get user by query
     * @param name User name regex
     * @param group User group id
     */
    getUser(params: { 'name'?: string; 'group'?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<User>> {
        const fetchArgs = UserApiFetchParamCreator.getUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Get user avatar image
     * @param id
     */
    getUserAvatar(params: { 'id': number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.getUserAvatar(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Get user by ID
     * @param id
     */
    getUserByName(params: { 'id': number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.getUserByName(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Logs user into the system. Return a token.
     * @param username The user name for login
     * @param password The password for login in clear text
     */
    loginUser(params: { 'username': string; 'password': string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = UserApiFetchParamCreator.loginUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Logs out current logged in user session
     */
    logoutUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.logoutUser(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 游客自助注册用户
     * @summary Signup user. Return a token.
     * @param body
     */
    signupUser(params: { 'body': Body;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = UserApiFetchParamCreator.signupUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This can only be done by the logged in user.
     * @summary Update user
     * @param id
     * @param body Updated user object
     */
    updateUser(params: { 'id': number; 'body': User;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.updateUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Upload user avatar image
     * @param id
     * @param file The image to upload.
     */
    uploadUserAvatar(params: { 'id': number; 'file'?: any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.uploadUserAvatar(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /**
     *
     * @summary Change user password
     * @param id
     * @param oldPassword
     * @param newPassword
     */
    changeUserPassword(params: {  'id': number; 'oldPassword': string; 'newPassword': string; }, options?: any) {
        return UserApiFp.changeUserPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * 管理员用户创建新用户
     * @summary Create user
     * @param body Created user object (Ignore id)
     */
    createUser(params: {  'body': User; }, options?: any) {
        return UserApiFp.createUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * This can only be done by the admin user.
     * @summary Delete user
     * @param id
     */
    deleteUser(params: {  'id': number; }, options?: any) {
        return UserApiFp.deleteUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * 搜索用户
     * @summary Get user by query
     * @param name User name regex
     * @param group User group id
     */
    getUser(params: {  'name'?: string; 'group'?: number; }, options?: any) {
        return UserApiFp.getUser(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Get user avatar image
     * @param id
     */
    getUserAvatar(params: {  'id': number; }, options?: any) {
        return UserApiFp.getUserAvatar(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Get user by ID
     * @param id
     */
    getUserByName(params: {  'id': number; }, options?: any) {
        return UserApiFp.getUserByName(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Logs user into the system. Return a token.
     * @param username The user name for login
     * @param password The password for login in clear text
     */
    loginUser(params: {  'username': string; 'password': string; }, options?: any) {
        return UserApiFp.loginUser(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Logs out current logged in user session
     */
    logoutUser(options?: any) {
        return UserApiFp.logoutUser(options)(this.fetch, this.basePath);
    }
    /**
     * 游客自助注册用户
     * @summary Signup user. Return a token.
     * @param body
     */
    signupUser(params: {  'body': Body; }, options?: any) {
        return UserApiFp.signupUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * This can only be done by the logged in user.
     * @summary Update user
     * @param id
     * @param body Updated user object
     */
    updateUser(params: {  'id': number; 'body': User; }, options?: any) {
        return UserApiFp.updateUser(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Upload user avatar image
     * @param id
     * @param file The image to upload.
     */
    uploadUserAvatar(params: {  'id': number; 'file'?: any; }, options?: any) {
        return UserApiFp.uploadUserAvatar(params, options)(this.fetch, this.basePath);
    }
}

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         *
         * @summary Change user password
         * @param id
         * @param oldPassword
         * @param newPassword
         */
        changeUserPassword(params: {  'id': number; 'oldPassword': string; 'newPassword': string; }, options?: any) {
            return UserApiFp.changeUserPassword(params, options)(fetch, basePath);
        },
        /**
         * 管理员用户创建新用户
         * @summary Create user
         * @param body Created user object (Ignore id)
         */
        createUser(params: {  'body': User; }, options?: any) {
            return UserApiFp.createUser(params, options)(fetch, basePath);
        },
        /**
         * This can only be done by the admin user.
         * @summary Delete user
         * @param id
         */
        deleteUser(params: {  'id': number; }, options?: any) {
            return UserApiFp.deleteUser(params, options)(fetch, basePath);
        },
        /**
         * 搜索用户
         * @summary Get user by query
         * @param name User name regex
         * @param group User group id
         */
        getUser(params: {  'name'?: string; 'group'?: number; }, options?: any) {
            return UserApiFp.getUser(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get user avatar image
         * @param id
         */
        getUserAvatar(params: {  'id': number; }, options?: any) {
            return UserApiFp.getUserAvatar(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get user by ID
         * @param id
         */
        getUserByName(params: {  'id': number; }, options?: any) {
            return UserApiFp.getUserByName(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Logs user into the system. Return a token.
         * @param username The user name for login
         * @param password The password for login in clear text
         */
        loginUser(params: {  'username': string; 'password': string; }, options?: any) {
            return UserApiFp.loginUser(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Logs out current logged in user session
         */
        logoutUser(options?: any) {
            return UserApiFp.logoutUser(options)(fetch, basePath);
        },
        /**
         * 游客自助注册用户
         * @summary Signup user. Return a token.
         * @param body
         */
        signupUser(params: {  'body': Body; }, options?: any) {
            return UserApiFp.signupUser(params, options)(fetch, basePath);
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update user
         * @param id
         * @param body Updated user object
         */
        updateUser(params: {  'id': number; 'body': User; }, options?: any) {
            return UserApiFp.updateUser(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Upload user avatar image
         * @param id
         * @param file The image to upload.
         */
        uploadUserAvatar(params: {  'id': number; 'file'?: any; }, options?: any) {
            return UserApiFp.uploadUserAvatar(params, options)(fetch, basePath);
        },
    };
};

